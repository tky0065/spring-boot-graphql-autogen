package com.enokdev.graphql.autogen.autoconfigure;

import com.enokdev.graphql.autogen.generator.*;
import com.enokdev.graphql.autogen.scanner.AnnotationScanner;
import com.enokdev.graphql.autogen.scanner.DefaultAnnotationScanner;
import graphql.GraphQL;
import graphql.schema.GraphQLSchema;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.core.env.Environment;

import jakarta.annotation.PostConstruct;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 * Auto-configuration for GraphQL AutoGen.
 * 
 * This configuration is automatically enabled when GraphQL is on the classpath
 * and spring.graphql.autogen.enabled is not set to false.
 * 
 * @author GraphQL AutoGen Team
 * @since 1.0.0
 */
@AutoConfiguration
@ConditionalOnClass(GraphQL.class)
@ConditionalOnProperty(prefix = "spring.graphql.autogen", name = "enabled", havingValue = "true", matchIfMissing = true)
@EnableConfigurationProperties(GraphQLAutoGenProperties.class)
@ComponentScan(basePackages = "com.enokdev.graphql.autogen")
public class GraphQLAutoGenAutoConfiguration {
    
    private static final Logger log = LoggerFactory.getLogger(GraphQLAutoGenAutoConfiguration.class);
    
    private final GraphQLAutoGenProperties properties;
    private final Environment environment;
    
    public GraphQLAutoGenAutoConfiguration(GraphQLAutoGenProperties properties, Environment environment) {
        this.properties = properties;
        this.environment = environment;
    }
    
    @PostConstruct
    public void logConfiguration() {
        log.info("GraphQL AutoGen auto-configuration enabled");
        log.debug("Base packages: {}", properties.getBasePackages());
        log.debug("Naming strategy: {}", properties.getNamingStrategy());
        log.debug("Generate inputs: {}", properties.isGenerateInputs());
        log.debug("Generate subscriptions: {}", properties.isGenerateSubscriptions());
    }
    
    @Bean
    @ConditionalOnMissingBean
    public AnnotationScanner annotationScanner() {
        log.debug("Creating DefaultAnnotationScanner bean");
        return new DefaultAnnotationScanner();
    }
    
    @Bean
    @ConditionalOnMissingBean
    public TypeResolver typeResolver() {
        log.debug("Creating DefaultTypeResolver bean");
        DefaultTypeResolver resolver = new DefaultTypeResolver();
        
        // Apply custom type mappings from configuration
        for (var entry : properties.getTypeMapping().entrySet()) {
            try {
                Class<?> javaType = Class.forName(entry.getKey());
                resolver.registerTypeMapping(javaType, entry.getValue());
                log.debug("Registered type mapping: {} -> {}", entry.getKey(), entry.getValue());
            } catch (ClassNotFoundException e) {
                log.warn("Cannot register type mapping for unknown class: {}", entry.getKey());
            }
        }
        
        return resolver;
    }
    
    @Bean
    @ConditionalOnMissingBean
    public FieldResolver fieldResolver(TypeResolver typeResolver) {
        log.debug("Creating DefaultFieldResolver bean");
        return new DefaultFieldResolver(typeResolver);
    }
    
    @Bean
    @ConditionalOnMissingBean
    public OperationResolver operationResolver(TypeResolver typeResolver) {
        log.debug("Creating DefaultOperationResolver bean");
        return new DefaultOperationResolver(typeResolver);
    }
    
    @Bean
    @ConditionalOnMissingBean
    public SchemaGenerator schemaGenerator(TypeResolver typeResolver,
                                         FieldResolver fieldResolver,
                                         OperationResolver operationResolver) {
        log.debug("Creating DefaultSchemaGenerator bean");
        return new DefaultSchemaGenerator(typeResolver, fieldResolver, operationResolver);
    }
    
    @Bean
    @ConditionalOnMissingBean(name = "autoGeneratedGraphQLSchema")
    public GraphQLSchema autoGeneratedGraphQLSchema(AnnotationScanner scanner, 
                                                   SchemaGenerator schemaGenerator) {
        log.info("Generating GraphQL schema automatically");
        
        try {
            // Determine base packages to scan
            List<String> basePackages = determineBasePackages();
            log.info("Scanning packages for GraphQL annotations: {}", basePackages);
            
            // Scan for annotated classes
            Set<Class<?>> annotatedClasses = scanner.scanForAnnotatedClasses(basePackages);
            log.info("Found {} annotated classes", annotatedClasses.size());
            
            if (annotatedClasses.isEmpty()) {
                log.warn("No GraphQL annotated classes found. Please check your base packages configuration.");
                log.warn("Current base packages: {}", basePackages);
                log.info("You can configure base packages with: spring.graphql.autogen.base-packages");
            }
            
            // Generate schema
            GraphQLSchema schema = schemaGenerator.generateSchema(new ArrayList<>(annotatedClasses));
            log.info("Successfully generated GraphQL schema with {} types", 
                    schema.getAllTypesAsList().size());
            
            // Log schema information
            logSchemaInfo(schema);
            
            // Generate schema file if requested
            if (properties.getSchema().isGenerateAtStartup()) {
                generateSchemaFile(schemaGenerator, annotatedClasses);
            }
            
            return schema;
            
        } catch (Exception e) {
            log.error("Failed to generate GraphQL schema", e);
            throw new RuntimeException("GraphQL schema generation failed", e);
        }
    }
    
    @Bean
    @ConditionalOnMissingBean
    public GraphQLSchemaInitializer schemaInitializer(GraphQLSchema schema) {
        log.debug("Creating GraphQLSchemaInitializer bean");
        return new GraphQLSchemaInitializer(schema, properties);
    }
    
    /**
     * Determines the base packages to scan.
     */
    private List<String> determineBasePackages() {
        List<String> basePackages = new ArrayList<>(properties.getBasePackages());
        
        // If no explicit base packages, try to detect from main application class
        if (basePackages.isEmpty()) {
            String mainClassName = environment.getProperty("spring.main.application-class");
            if (mainClassName != null) {
                try {
                    Class<?> mainClass = Class.forName(mainClassName);
                    String packageName = mainClass.getPackage().getName();
                    basePackages.add(packageName);
                    log.info("Auto-detected base package from main class: {}", packageName);
                } catch (ClassNotFoundException e) {
                    log.debug("Could not load main application class: {}", mainClassName);
                }
            }
            
            // Fallback: scan common package patterns
            if (basePackages.isEmpty()) {
                basePackages.add("com");
                basePackages.add("org");
                log.warn("No base packages configured. Using fallback packages: {}", basePackages);
                log.info("Consider configuring: spring.graphql.autogen.base-packages");
            }
        }
        
        return basePackages;
    }
    
    /**
     * Logs information about the generated schema.
     */
    private void logSchemaInfo(GraphQLSchema schema) {
        if (log.isInfoEnabled()) {
            log.info("GraphQL Schema Summary:");
            log.info("  - Query type: {}", schema.getQueryType() != null ? schema.getQueryType().getName() : "none");
            log.info("  - Mutation type: {}", schema.getMutationType() != null ? schema.getMutationType().getName() : "none");
            log.info("  - Subscription type: {}", schema.getSubscriptionType() != null ? schema.getSubscriptionType().getName() : "none");
            log.info("  - Total types: {}", schema.getAllTypesAsList().size());
            
            if (schema.getQueryType() != null) {
                log.info("  - Query operations: {}", schema.getQueryType().getChildren().size());
            }
            if (schema.getMutationType() != null) {
                log.info("  - Mutation operations: {}", schema.getMutationType().getChildren().size());
            }
            if (schema.getSubscriptionType() != null) {
                log.info("  - Subscription operations: {}", schema.getSubscriptionType().getChildren().size());
            }
        }
    }
    
    /**
     * Generates the schema file if configured.
     */
    private void generateSchemaFile(SchemaGenerator schemaGenerator, Set<Class<?>> annotatedClasses) {
        try {
            String schemaString = schemaGenerator.generateSchemaString(new ArrayList<>(annotatedClasses));
            String location = properties.getSchema().getLocation();
            String fileName = properties.getSchema().getFileName();
            
            log.info("Generated GraphQL schema will be available at: {}{}", location, fileName);
            log.debug("Schema content preview (first 500 chars): {}", 
                     schemaString.length() > 500 ? schemaString.substring(0, 500) + "..." : schemaString);
            
            // Note: In a real implementation, you would write this to the filesystem
            // For now, we just log that it would be generated
            
        } catch (Exception e) {
            log.error("Failed to generate schema file", e);
        }
    }
}
